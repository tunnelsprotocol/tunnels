//! Single peer connection handler.

use std::net::SocketAddr;
use std::sync::Arc;

use futures::{SinkExt, StreamExt};
use tokio::net::TcpStream;
use tokio::sync::mpsc;
use tokio::time::{interval, timeout, Instant};
use tokio_util::codec::Framed;

use crate::config::P2pConfig;
use crate::error::{P2pError, P2pResult};
use crate::peer::{ConnectionDirection, PeerContext, PeerId, PeerInfo, PeerState};
use crate::protocol::{
    create_version_message, HandshakeState, Message, MessageCodec,
};

/// Commands that can be sent to a peer connection.
#[derive(Debug)]
#[allow(clippy::large_enum_variant)]
pub enum PeerCommand {
    /// Send a message to the peer.
    Send(Message),
    /// Disconnect the peer.
    Disconnect,
}

/// Events generated by a peer connection.
pub enum PeerEvent {
    /// Connection established and handshake complete.
    Connected {
        peer_id: PeerId,
        info: PeerInfo,
        /// Command channel to send messages to this peer.
        /// Used to register outbound connections with PeerManager.
        command_tx: mpsc::UnboundedSender<PeerCommand>,
    },
    /// Received a message from the peer.
    Message {
        peer_id: PeerId,
        message: Box<Message>,
    },
    /// Peer disconnected.
    Disconnected {
        peer_id: PeerId,
        reason: String,
    },
    /// Handshake failed.
    HandshakeFailed {
        peer_id: PeerId,
        addr: SocketAddr,
        error: String,
    },
}

impl std::fmt::Debug for PeerEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PeerEvent::Connected { peer_id, info, .. } => {
                f.debug_struct("Connected")
                    .field("peer_id", peer_id)
                    .field("info", info)
                    .finish()
            }
            PeerEvent::Message { peer_id, message } => {
                f.debug_struct("Message")
                    .field("peer_id", peer_id)
                    .field("message", message)
                    .finish()
            }
            PeerEvent::Disconnected { peer_id, reason } => {
                f.debug_struct("Disconnected")
                    .field("peer_id", peer_id)
                    .field("reason", reason)
                    .finish()
            }
            PeerEvent::HandshakeFailed { peer_id, addr, error } => {
                f.debug_struct("HandshakeFailed")
                    .field("peer_id", peer_id)
                    .field("addr", addr)
                    .field("error", error)
                    .finish()
            }
        }
    }
}

/// Handler for a single peer connection.
pub struct PeerConnection {
    /// Unique ID for this peer.
    peer_id: PeerId,
    /// Socket address of the peer.
    addr: SocketAddr,
    /// Direction of the connection.
    direction: ConnectionDirection,
    /// Framed TCP stream for message I/O.
    framed: Framed<TcpStream, MessageCodec>,
    /// Channel to receive commands from the node (unbounded to avoid deadlock).
    command_rx: mpsc::UnboundedReceiver<PeerCommand>,
    /// Channel to send commands to this peer (for registration with PeerManager).
    command_tx: mpsc::UnboundedSender<PeerCommand>,
    /// Channel to send events to the node.
    event_tx: mpsc::Sender<PeerEvent>,
    /// Peer info.
    info: PeerInfo,
    /// Peer interaction context.
    context: PeerContext,
    /// P2P configuration.
    config: Arc<P2pConfig>,
    /// Genesis hash for handshake validation.
    genesis_hash: [u8; 32],
    /// Our best height.
    best_height: u64,
    /// Our best hash.
    best_hash: [u8; 32],
    /// Time when we sent the last ping (for RTT measurement).
    ping_sent_at: Option<Instant>,
}

impl PeerConnection {
    /// Create a new peer connection handler.
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        peer_id: PeerId,
        addr: SocketAddr,
        direction: ConnectionDirection,
        stream: TcpStream,
        command_rx: mpsc::UnboundedReceiver<PeerCommand>,
        command_tx: mpsc::UnboundedSender<PeerCommand>,
        event_tx: mpsc::Sender<PeerEvent>,
        config: Arc<P2pConfig>,
        genesis_hash: [u8; 32],
        best_height: u64,
        best_hash: [u8; 32],
    ) -> Self {
        let framed = Framed::new(stream, MessageCodec::new());
        let info = PeerInfo::new(peer_id, addr, direction);

        Self {
            peer_id,
            addr,
            direction,
            framed,
            command_rx,
            command_tx,
            event_tx,
            info,
            context: PeerContext::new(),
            config,
            genesis_hash,
            best_height,
            best_hash,
            ping_sent_at: None,
        }
    }

    /// Run the peer connection loop.
    pub async fn run(mut self) {
        // Perform handshake
        match self.handshake().await {
            Ok(()) => {
                tracing::info!(peer = %self.peer_id, addr = %self.addr, "Handshake complete");
            }
            Err(e) => {
                tracing::warn!(peer = %self.peer_id, addr = %self.addr, error = %e, "Handshake failed");
                let _ = self
                    .event_tx
                    .send(PeerEvent::HandshakeFailed {
                        peer_id: self.peer_id,
                        addr: self.addr,
                        error: e.to_string(),
                    })
                    .await;
                return;
            }
        }

        // Notify connected (include command_tx so PeerManager can register this peer)
        let _ = self
            .event_tx
            .send(PeerEvent::Connected {
                peer_id: self.peer_id,
                info: self.info.clone(),
                command_tx: self.command_tx.clone(),
            })
            .await;

        // Run main message loop
        if let Err(e) = self.message_loop().await {
            tracing::debug!(peer = %self.peer_id, error = %e, "Connection ended");
        }

        // Notify disconnected
        let _ = self
            .event_tx
            .send(PeerEvent::Disconnected {
                peer_id: self.peer_id,
                reason: "Connection closed".to_string(),
            })
            .await;
    }

    /// Perform the version handshake.
    async fn handshake(&mut self) -> P2pResult<()> {
        let mut handshake = HandshakeState::new();

        // For outbound connections, we send version first
        if self.direction == ConnectionDirection::Outbound {
            let version = create_version_message(
                self.genesis_hash,
                self.best_height,
                self.best_hash,
                &self.config.user_agent,
                Some(self.config.bind_addr),
            );
            self.send_message(Message::Version(version)).await?;
            handshake.sent_version()?;
            self.context.transition_to(PeerState::VersionSent);
        }

        let handshake_timeout = self.config.handshake_timeout;

        // Handshake loop
        loop {
            let message = timeout(handshake_timeout, self.framed.next())
                .await
                .map_err(|_| P2pError::HandshakeTimeout)?
                .ok_or_else(|| P2pError::PeerDisconnected {
                    reason: "Connection closed during handshake".to_string(),
                })?
                .map_err(|e| P2pError::Io(std::io::Error::other(e.to_string())))?;

            match message {
                Message::Version(version) => {
                    handshake.received_version(version.clone(), self.genesis_hash)?;

                    // Update peer info
                    self.info.best_height = version.best_height;
                    self.info.best_hash = version.best_hash;

                    // If we haven't sent our version yet (inbound), send it now
                    if self.direction == ConnectionDirection::Inbound {
                        let our_version = create_version_message(
                            self.genesis_hash,
                            self.best_height,
                            self.best_hash,
                            &self.config.user_agent,
                            Some(self.config.bind_addr),
                        );
                        self.send_message(Message::Version(our_version)).await?;
                        handshake.sent_version()?;
                    }

                    // Send version ack
                    self.send_message(Message::VersionAck).await?;
                    handshake.sent_version_ack()?;
                }
                Message::VersionAck => {
                    handshake.received_version_ack()?;

                    if let Some(result) = handshake.result() {
                        self.info.complete_handshake(
                            result.protocol_version,
                            result.user_agent.clone(),
                            result.best_height,
                            result.best_hash,
                        );
                        self.context.transition_to(PeerState::Connected);
                        return Ok(());
                    }
                }
                other => {
                    return Err(P2pError::UnexpectedMessage {
                        expected: "Version or VersionAck".to_string(),
                        actual: other.name().to_string(),
                    });
                }
            }
        }
    }

    /// Main message processing loop.
    async fn message_loop(&mut self) -> P2pResult<()> {
        let mut ping_interval = interval(self.config.ping_interval);
        let mut ping_nonce: u64 = 0;

        loop {
            tokio::select! {
                // Handle incoming messages
                msg = self.framed.next() => {
                    match msg {
                        Some(Ok(message)) => {
                            self.handle_message(message).await?;
                        }
                        Some(Err(e)) => {
                            return Err(e);
                        }
                        None => {
                            return Err(P2pError::PeerDisconnected {
                                reason: "Connection closed".to_string(),
                            });
                        }
                    }
                }

                // Handle commands from node
                cmd = self.command_rx.recv() => {
                    match cmd {
                        Some(PeerCommand::Send(msg)) => {
                            self.send_message(msg).await?;
                        }
                        Some(PeerCommand::Disconnect) => {
                            self.context.transition_to(PeerState::Disconnecting);
                            return Ok(());
                        }
                        None => {
                            // Command channel closed
                            return Ok(());
                        }
                    }
                }

                // Periodic ping
                _ = ping_interval.tick() => {
                    ping_nonce = ping_nonce.wrapping_add(1);
                    self.info.last_ping_nonce = Some(ping_nonce);
                    self.ping_sent_at = Some(Instant::now());
                    self.send_message(Message::Ping(ping_nonce)).await?;
                }
            }
        }
    }

    /// Handle an incoming message.
    async fn handle_message(&mut self, message: Message) -> P2pResult<()> {
        tracing::trace!(peer = %self.peer_id, msg = %message, "Received message");

        match &message {
            Message::Ping(nonce) => {
                // Respond immediately with pong
                self.send_message(Message::Pong(*nonce)).await?;
            }
            Message::Pong(nonce) => {
                // Check if this matches our last ping
                if self.info.last_ping_nonce == Some(*nonce) {
                    // Calculate RTT from ping send time
                    if let Some(sent_at) = self.ping_sent_at.take() {
                        let rtt = sent_at.elapsed();
                        self.info.ping_rtt = Some(rtt);
                        tracing::trace!(peer = %self.peer_id, rtt = ?rtt, "Measured ping RTT");
                    }
                    self.info.last_ping_nonce = None;
                    self.context.record_success();
                }
            }
            _ => {
                // Forward all other messages to the node
                let _ = self
                    .event_tx
                    .send(PeerEvent::Message {
                        peer_id: self.peer_id,
                        message: Box::new(message),
                    })
                    .await;
            }
        }

        Ok(())
    }

    /// Send a message to the peer.
    async fn send_message(&mut self, message: Message) -> P2pResult<()> {
        tracing::trace!(peer = %self.peer_id, msg = %message, "Sending message");
        self.framed
            .send(message)
            .await
            .map_err(|e: crate::error::P2pError| P2pError::Io(std::io::Error::other(e.to_string())))
    }
}

/// Spawn a peer connection task.
/// Returns (command_tx, join_handle) for sending commands and tracking the task.
///
/// Uses unbounded channel for commands to avoid deadlock:
/// - Node sends commands to peer tasks
/// - Peer tasks send events to node
/// - Bounded channels in both directions could deadlock if both fill up
/// - Commands are trusted (from our own node), so unbounded is safe
#[allow(clippy::too_many_arguments)]
pub fn spawn_peer_connection(
    peer_id: PeerId,
    addr: SocketAddr,
    direction: ConnectionDirection,
    stream: TcpStream,
    event_tx: mpsc::Sender<PeerEvent>,
    config: Arc<P2pConfig>,
    genesis_hash: [u8; 32],
    best_height: u64,
    best_hash: [u8; 32],
) -> (mpsc::UnboundedSender<PeerCommand>, tokio::task::JoinHandle<()>) {
    // Use unbounded channel for commands to avoid deadlock with bounded event channel
    let (command_tx, command_rx) = mpsc::unbounded_channel();

    let connection = PeerConnection::new(
        peer_id,
        addr,
        direction,
        stream,
        command_rx,
        command_tx.clone(),
        event_tx,
        config,
        genesis_hash,
        best_height,
        best_hash,
    );

    let handle = tokio::spawn(connection.run());

    (command_tx, handle)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_peer_command_debug() {
        let cmd = PeerCommand::Send(Message::Ping(42));
        assert!(format!("{:?}", cmd).contains("Ping"));
    }

    #[test]
    fn test_peer_event_debug() {
        let event = PeerEvent::Disconnected {
            peer_id: PeerId::new(1),
            reason: "test".to_string(),
        };
        assert!(format!("{:?}", event).contains("Disconnected"));
    }
}
